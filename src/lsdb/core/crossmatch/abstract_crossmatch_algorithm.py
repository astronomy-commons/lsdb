from __future__ import annotations

from abc import ABC, abstractmethod
from typing import Tuple

import hipscat as hc
import pandas as pd
from hipscat.pixel_math.hipscat_id import HIPSCAT_ID_COLUMN


# pylint: disable=too-many-instance-attributes, too-many-arguments
class AbstractCrossmatchAlgorithm(ABC):
    """Abstract class used to write a crossmatch algorithm"""

    extra_columns: pd.DataFrame | None = None
    """The metadata for the columns generated by the crossmatch algorithm"""

    def __init__(
        self,
        left: pd.DataFrame,
        right: pd.DataFrame,
        left_order: int,
        left_pixel: int,
        right_order: int,
        right_pixel: int,
        left_metadata: hc.catalog.Catalog,
        right_metadata: hc.catalog.Catalog,
        right_margin_hc_structure: hc.catalog.MarginCatalog | None,
        suffixes: Tuple[str, str],
    ):
        """Initializes a crossmatch algorithm

        Args:
            left (pd.DataFrame): Data from the pixel in the left tree
            right (pd.DataFrame): Data from the pixel in the right tree
            left_order (int): The HEALPix order of the left pixel
            left_pixel (int): The HEALPix pixel number in NESTED ordering of the left pixel
            right_order (int): The HEALPix order of the right pixel
            right_pixel (int): The HEALPix pixel number in NESTED ordering of the right pixel
            left_metadata (hipscat.Catalog): The hipscat Catalog object with the metadata of the
                left catalog
            right_metadata (hipscat.Catalog): The hipscat Catalog object with the metadata of the
                right catalog
            right_margin_hc_structure (hipscat.MarginCatalog): The hipscat MarginCatalog objects
                with the metadata of the right **margin** catalog
            suffixes (Tuple[str,str]): A pair of suffixes to be appended to the end of each column
                name, with the first appended to the left columns and the second to the right
                columns
        """
        self.left = left.copy(deep=False)
        self.right = right.copy(deep=False)
        self.left_order = left_order
        self.left_pixel = left_pixel
        self.right_order = right_order
        self.right_pixel = right_pixel
        self.left_metadata = left_metadata
        self.right_metadata = right_metadata
        self.right_margin_hc_structure = right_margin_hc_structure
        self.suffixes = suffixes

    @abstractmethod
    def crossmatch(self) -> pd.DataFrame:
        """Perform a crossmatch"""

    # pylint: disable=unused-argument
    def validate(self, *args, **kwargs):
        """Validate the metadata and arguments.

        This method will be called **once**, after the algorithm object has
        been initialized, during the lazy construction of the execution graph.
        This can be used to catch simple errors without waiting for an
        expensive ``.compute()`` call."""
        # Check that we have the appropriate columns in our dataset.
        if self.left.index.name != HIPSCAT_ID_COLUMN:
            raise ValueError(f"index of left table must be {HIPSCAT_ID_COLUMN}")
        if self.right.index.name != HIPSCAT_ID_COLUMN:
            raise ValueError(f"index of right table must be {HIPSCAT_ID_COLUMN}")
        column_names = self.left.columns
        if self.left_metadata.catalog_info.ra_column not in column_names:
            raise ValueError(f"left table must have column {self.left_metadata.catalog_info.ra_column}")
        if self.left_metadata.catalog_info.dec_column not in column_names:
            raise ValueError(f"left table must have column {self.left_metadata.catalog_info.dec_column}")

        column_names = self.right.columns
        if self.right_metadata.catalog_info.ra_column not in column_names:
            raise ValueError(f"right table must have column {self.right_metadata.catalog_info.ra_column}")
        if self.right_metadata.catalog_info.dec_column not in column_names:
            raise ValueError(f"right table must have column {self.right_metadata.catalog_info.dec_column}")

    @staticmethod
    def _rename_columns_with_suffix(dataframe, suffix):
        columns_renamed = {name: name + suffix for name in dataframe.columns}
        dataframe.rename(columns=columns_renamed, inplace=True)

    @classmethod
    def _append_extra_columns(cls, dataframe: pd.DataFrame, extra_columns: pd.DataFrame | None = None):
        """Adds crossmatch extra columns to the resulting Dataframe."""
        if cls.extra_columns is None:
            return
        if extra_columns is None:
            raise ValueError("No extra column values were provided")
        # Check if the provided columns are in the specification
        for col in extra_columns.columns:
            if col not in cls.extra_columns.columns:
                raise ValueError(f"Provided extra column '{col}' not found in definition")
        # Update columns according to crossmatch algorithm specification
        columns_to_update = []
        for col, col_type in cls.extra_columns.items():
            if col not in extra_columns:
                raise ValueError(f"Missing extra column '{col} of type {col_type}'")
            if col_type.dtype != extra_columns[col].dtype:
                raise ValueError(f"Invalid type '{col_type}' for extra column '{col}'")
            columns_to_update.append(col)
        for col in columns_to_update:
            dataframe[col] = extra_columns[col].values
