from __future__ import annotations

from typing import TYPE_CHECKING

import numpy as np
import pandas as pd
import pyarrow as pa

from lsdb.core.crossmatch.kdtree_match import KdTreeCrossmatch
from lsdb.core.crossmatch.kdtree_utils import _find_crossmatch_indices, _get_chord_distance

if TYPE_CHECKING:
    from lsdb import Catalog


class BoundedKdTreeCrossmatch(KdTreeCrossmatch):
    """Nearest neighbor crossmatch using a distance range"""

    @classmethod
    def validate(
        cls,
        left: Catalog,
        right: Catalog,
        n_neighbors: int = 1,
        radius_arcsec: float = 1,
        min_radius_arcsec: float = 0,
    ):
        """Validate the metadata and arguments.

        Parameters
        ----------
        left: Catalog
            The left catalog for the crossmatch.
        right: Catalog
            The right catalog for the crossmatch.
        n_neighbors : int, default 1
            The number of neighbors to find within each point.
        radius_arcsec : float, default 1
            The threshold distance in arcseconds beyond which neighbors are not added
        min_radius_arcsec : float, default 0
            The minimum distance from which neighbors are added
        """
        super().validate(left, right, n_neighbors, radius_arcsec)
        if min_radius_arcsec < 0:
            raise ValueError("The minimum radius must be non-negative")
        if radius_arcsec <= min_radius_arcsec:
            raise ValueError("Cross match maximum radius must be greater than cross match minimum radius")

    def perform_crossmatch(
        self,
        n_neighbors: int = 1,
        radius_arcsec: float = 1,
        min_radius_arcsec: float = 0,
    ) -> tuple[np.ndarray, np.ndarray, pd.DataFrame]:
        """Perform a cross-match between the data from two HEALPix pixels
        
        Finds the n closest neighbors in the right catalog for each point in the left catalog that
        are within a threshold distance by using a K-D Tree.

        Parameters
        ----------
        n_neighbors : int, default 1
            The number of neighbors to find within each point.
        radius_arcsec : float, default 1
            The threshold distance in arcseconds beyond which neighbors are not added
        min_radius_arcsec : float, default 0
            The minimum distance from which neighbors are added

        Returns
        -------
        tuple[np.ndarray, np.ndarray, pd.DataFrame]
            - a numpy array with the indices of the matching rows from the left table
            - a numpy array with the indices of the matching rows from the right table
            - a pandas dataframe with any additional columns generated by the algorithm
        These all must have the same lengths.
        """
        # Distance in 3-D space for unit sphere
        max_d_chord = _get_chord_distance(radius_arcsec)
        min_d_chord = _get_chord_distance(min_radius_arcsec)
        # calculate the cartesian coordinates of the points
        left_xyz, right_xyz = self._get_point_coordinates()
        # get matching indices for cross-matched rows
        chord_distances, left_idx, right_idx = _find_crossmatch_indices(
            left_xyz, right_xyz, n_neighbors=n_neighbors, min_distance=min_d_chord, max_distance=max_d_chord
        )
        arc_distances = np.degrees(2.0 * np.arcsin(0.5 * chord_distances)) * 3600
        extra_columns = pd.DataFrame(
            {"_dist_arcsec": pd.Series(arc_distances, dtype=pd.ArrowDtype(pa.float64()))}
        )
        return left_idx, right_idx, extra_columns
